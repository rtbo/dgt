module gen_bidi_tables;

import std.uni;
import std.stdio;
import std.getopt;
import std.typecons;
import std.exception;
import std.string;
import std.conv;
import std.traits;
import std.meta;

enum IndexedBidiClass : ubyte
{
    AL = 0,
    AN,
    B,
    BN,
    CS,
    EN,
    ES,
    ET,
    FSI,
    L,
    LRE,
    LRI,
    LRO,
    NSM,
    ON,
    PDF,
    PDI,
    R,
    RLE,
    RLI,
    RLO,
    S,
    WS,
}

IndexedBidiClass toBidiClass(S)(in S str) if (isSomeString!S)
{
    foreach(c; EnumMembers!IndexedBidiClass)
    {
        if (c.to!string == str) return c;
    }
	throw new Exception("");
}

int main(string[] args)
{
    string moduleName;
    string unicodeVersion;
    string ucdFilename;
    string outFilename;
    auto options = getopt(args,
        "module", "Generated module name (mandatory)", &moduleName,
        "unicode", "The Unicode version of the given UnicodeData.txt (mandatory)", &unicodeVersion,
        "ucd", "UCD/UnicodeData.txt file path [stdin]", &ucdFilename,
        "out", "Output module file path [stdout]", &outFilename,
    );

    if (options.helpWanted)
    {
        defaultGetoptPrinter("Generate Bidirectional character class table.", options.options);
        return 0;
    }
    if (!moduleName.length)
    {
        defaultGetoptPrinter("--module is mandatory.", options.options);
        return 1;
    }
    if (!unicodeVersion.length)
    {
        defaultGetoptPrinter("--unicode is mandatory.", options.options);
        return 1;
    }
    auto ucdF = ucdFilename.length ? File(ucdFilename, "r") : stdin;
    ubyte[dchar] bidiClassMap;
    foreach(l; ucdF.byLine)
    {
        const sl = l.split(";");
        enforce(!sl.empty && sl.length > 4);
        if (sl[4].length)
        {
            bidiClassMap[cast(dchar) (sl[0].to!uint(16))] =
                cast(ubyte)(toBidiClass(sl[4]));
        }
    }
    auto outF = outFilename.length ? File(outFilename, "w") : stdout;
    outF.writefln("/// Module generated by dgt/tools/gen_bidi_table");
    outF.writefln("/// Generated from UCD version %s", unicodeVersion);
    outF.writefln("module %s;", moduleName);
    outF.writeln();
    outF.writefln("enum IndexedBidiClass : uint");
    outF.writefln("{");
    foreach(c; EnumMembers!IndexedBidiClass)
    {
        outF.writefln("    %s,", c.to!string);
    }
    outF.writefln("}\n");
    outF.writefln("struct TrieEntry(T...)");
    outF.writefln("{");
    outF.writefln("    size_t[] offsets;");
    outF.writefln("    size_t[] sizes;");
    outF.writefln("    size_t[] data;");
    outF.writefln("}\n");
    alias Sizes = AliasSeq!(8, 5, 8);
    // defaults to "L" class
    auto trie = codepointTrie!(ubyte, Sizes)(bidiClassMap, cast(ubyte)IndexedBidiClass.L);
    outF.writefln("// %s bytes", trie.bytes);
    outF.writef("enum bidiClassTrieEntries = TrieEntry!(ubyte, %s, %s, %s) (\n", Sizes);
    trie.store(outF.lockingTextWriter);
    outF.writeln("\n);");
    return 0;
}
