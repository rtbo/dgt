module gen_bidi_tables;

import std.uni;
import std.stdio;
import std.getopt;
import std.typecons;
import std.exception;
import std.string;
import std.conv;
import std.traits;
import std.meta;
import std.array;
import std.format;
import std.range;

/// Bidi class enum that can be used as index.
/// Idea is that the enum used by application use masks to retrieve other
/// properties on the fly, and the trie return an index to lookup values in the
/// enum
enum IndexedBidiClass : ubyte
{
    AL = 0,
    AN,
    B,
    BN,
    CS,
    EN,
    ES,
    ET,
    FSI,
    L,
    LRE,
    LRI,
    LRO,
    NSM,
    ON,
    PDF,
    PDI,
    R,
    RLE,
    RLI,
    RLO,
    S,
    WS,
}

/// Convert a string into an IndexedBidiClass
IndexedBidiClass toBidiClass(S)(in S str) if (isSomeString!S)
{
    foreach(c; EnumMembers!IndexedBidiClass)
    {
        if (c.to!string == str) return c;
    }
	throw new Exception("");
}

/// Holds the internal data used by the trie.
struct TrieTable
{
    size_t[] offsets;
    size_t[] sizes;
    size_t[] storage;
}


int main(string[] args)
{
    string moduleName;
    string unicodeVersion;
    string ucdFilename;
    string outFilename;
    auto options = getopt(args,
        "module", "Generated module name (mandatory)", &moduleName,
        "unicode", "The Unicode version of the given UnicodeData.txt (mandatory)", &unicodeVersion,
        "ucd", "UCD/UnicodeData.txt file path [stdin]", &ucdFilename,
        "out", "Output module file path [stdout]", &outFilename,
    );

    if (options.helpWanted)
    {
        defaultGetoptPrinter("Generate Bidirectional character class table.", options.options);
        return 0;
    }
    if (!moduleName.length)
    {
        defaultGetoptPrinter("--module is mandatory.", options.options);
        return 1;
    }
    if (!unicodeVersion.length)
    {
        defaultGetoptPrinter("--unicode is mandatory.", options.options);
        return 1;
    }
    auto ucdF = ucdFilename.length ? File(ucdFilename, "r") : stdin;
    ubyte[dchar] bidiClassMap;
    foreach(l; ucdF.byLine)
    {
        const sl = l.split(";");
        enforce(!sl.empty && sl.length > 4);
        if (sl[4].length)
        {
            bidiClassMap[cast(dchar) (sl[0].to!uint(16))] =
                cast(ubyte)(toBidiClass(sl[4]));
        }
    }

    auto outF = outFilename.length ? File(outFilename, "w") : stdout;
    outF.writefln("/// Module generated by dgt/tools/gen_bidi_table");
    outF.writefln("/// Generated from UCD version %s", unicodeVersion);
    outF.writefln("module %s;", moduleName);
    outF.writeln();
    outF.writefln("enum IndexedBidiClass : uint");
    outF.writefln("{");
    foreach(c; EnumMembers!IndexedBidiClass)
    {
        outF.writefln("    %s,", c.to!string);
    }
    outF.writefln("}\n");
    outF.writefln("struct TrieEntry(T...)");
    outF.writefln("{");
    outF.writefln("    size_t[] offsets;");
    outF.writefln("    size_t[] sizes;");
    outF.writefln("    size_t[] data;");
    outF.writefln("}\n");

    alias Sizes = AliasSeq!(9, 7, 5);
    // defaults to "L" class
    auto trie = codepointTrie!(ubyte, Sizes)(bidiClassMap, cast(ubyte)IndexedBidiClass.L);

    auto output = appender!string();
    trie.store(output);
    string tableText = output.data;

    TrieTable table;
    formattedRead(tableText, "[%( 0x%x, %)]", &table.offsets);
    formattedRead(tableText, ", [%( 0x%x, %)]", &table.sizes);
    formattedRead(tableText, ", [%( 0x%x, %)]", &table.storage);

    static if (size_t.sizeof == 8)
    {
        import std.algorithm : canFind;
        enforce(!table.offsets.canFind!(v => v > uint.max) &&
                !table.sizes.canFind!(v => v > uint.max),
                "Bidi class trie is not compatible with 32bits archs");
    }
    else
    {
        // FIXME: adapt the 32 bits storage of odd length for 64 bits.
        if ((table.storage.length % 2) != 0)
        {
            stderr.writeln("Warning: handling storage misalignment for 64 bits");
            table.storage ~= 0;
        }
    }

    immutable bytes = table.storage.length * size_t.sizeof;

    static if (size_t.sizeof == 8)
    {
        alias issueTable64 = issueTable!(ulong, 1, 1);
        alias issueTable32 = issueTable!(uint, 2, 1);
    }
    else
    {
        alias issueTable64 = issueTable!(ulong, 1, 2, Sizes);
        alias issueTable32 = issueTable!(uint, 1, 1, Sizes);
    }

    outF.writeln("static if (size_t.sizeof == 8)\n{\n");
    outF.writefln("// %s bytes", bytes);
    outF.writef("enum bidiClassTrieEntries = TrieEntry!(ubyte, %s, %s, %s) (\n", Sizes);
    issueTable64(outF.lockingTextWriter, table);
    outF.writeln("\n);\n");
    outF.writeln("}\n\n");

    outF.writeln("static if (size_t.sizeof == 4)\n{\n");
    outF.writefln("// %s bytes", bytes);
    outF.writef("enum bidiClassTrieEntries = TrieEntry!(ubyte, %s, %s, %s) (\n", Sizes);
    issueTable32(outF.lockingTextWriter, table);
    outF.writeln("\n);\n");
    outF.writeln("}");


    return 0;
}

private template issueTable(StorT, int Num, int Den)
{
    void issueTable(Sink)(Sink sink, in TrieTable table)
    //if (isOuputRange!(Sink, char))
    {
        import std.algorithm : map;
        formattedWrite(sink, "[%( 0x%x, %)]", table.offsets);
        formattedWrite(sink, ", [%( 0x%x, %)]", table.sizes.map!(s => s*Num/Den).array);
        formattedWrite(sink, ", [%( 0x%x, %)]", cast(const(StorT)[])table.storage);
    }
}
